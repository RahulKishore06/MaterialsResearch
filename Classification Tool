# -------------------------------
# Imports
# -------------------------------
from mp_api.client import MPRester
from pymatgen.electronic_structure.core import Spin
from pymatgen.electronic_structure.plotter import BSDOSPlotter
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# API Access
# -------------------------------
mpr = MPRester()

# -------------------------------
# Material Selection
# -------------------------------
mid = "mp-149"  # Silicon
bs = mpr.get_bandstructure_by_material_id(mid)
dos = mpr.get_dos_by_material_id(mid)
structure = mpr.get_structure_by_material_id(mid)

print(f"--Structure:--\n{structure}")

# -------------------------------
# BSDOS Plot
# -------------------------------
bsp = BSDOSPlotter()
ax_bs, ax_dos = bsp.get_plot(bs, dos)

# -------------------------------
# Tabulate DOS
# -------------------------------
energies = dos.energies - dos.efermi

if Spin.down in dos.densities:
    total_dos = dos.densities[Spin.up] + dos.densities[Spin.down]
else:
    total_dos = dos.densities[Spin.up]

dos_df = pd.DataFrame({
    "Energy (eV)": energies,
    "Total DOS (states/eV)": total_dos
})

print("--DOS Table--")
print(dos_df.head())

# -------------------------------
# Analyze Parallel Regions
# -------------------------------

def analyze_direct_bandgap_singularities(bs, N=3, slope_tol=50.0):
    """
    Analyze direct band gaps and identify type 2 singularities
    where gradient d(Ec - Ev)/dk exceeds slope_tol.
    Only considers energy gaps in [E_gap, 5*E_gap] range.
    Returns a DataFrame of k-point info.
    """
    from pymatgen.electronic_structure.core import Spin
    import numpy as np
    import pandas as pd
    import matplotlib.pyplot as plt

    spin = Spin.up
    bands = bs.bands[spin]
    fermi = bs.efermi
    kpoints = np.array(bs.distance)

    # Shift bands relative to Fermi level
    shifted_bands = [band - fermi for band in bands]

    # Identify valence (below Ef) and conduction (above Ef) bands
    band_info = [(i, np.mean(b)) for i, b in enumerate(shifted_bands)]
    valence_bands = sorted([i for i, e in band_info if e < 0], key=lambda i: abs(np.mean(shifted_bands[i])))[:N]
    conduction_bands = sorted([i for i, e in band_info if e > 0], key=lambda i: abs(np.mean(shifted_bands[i])))[:N]

    print(f"Valence bands: {valence_bands}")
    print(f"Conduction bands: {conduction_bands}")

    # Collect analysis results
    records = []

    plt.figure(figsize=(10, 6))
    min_gap_val = float("inf")
    min_gap_idx = None

    for vb in valence_bands:
        for cb in conduction_bands:
            Ev = shifted_bands[vb]
            Ec = shifted_bands[cb]
            gap = Ec - Ev

            # Skip bands that cross (metallic)
            if np.any(gap <= 0):
                continue

            Egap = np.min(gap)
            max_range = 5 * Egap
            in_range = (gap >= Egap) & (gap <= max_range)

            grad = np.gradient(gap, kpoints)
            grad_magnitude = np.abs(grad)

            for i in range(len(kpoints)):
                if not in_range[i]:
                    continue
                records.append({
                    "k-point (1/Å)": kpoints[i],
                    "Ev (eV)": Ev[i],
                    "Ec (eV)": Ec[i],
                    "Ec - Ev (eV)": gap[i],
                    "d(Ec - Ev)/dk (eV/Å)": grad[i],
                    "Singular": grad_magnitude[i] > slope_tol
                })

            # Track minimum direct gap
            local_min_idx = np.argmin(gap)
            if gap[local_min_idx] < min_gap_val:
                min_gap_val = gap[local_min_idx]
                min_gap_idx = local_min_idx
                min_gap_k = kpoints[local_min_idx]
                min_gap_label = f"B{cb+1}-B{vb+1}"

            # Plot gradients and mark singularities
            plt.plot(kpoints, grad, label=f"{cb+1}-{vb+1}")
            singular_pts = grad_magnitude > slope_tol
            plt.plot(kpoints[singular_pts], grad[singular_pts], 'rx', markersize=4)

    # Highlight minimum gap point
    if min_gap_idx is not None:
        plt.axvline(kpoints[min_gap_idx], color='k', linestyle='--', label="Min Gap")
        print(f"Minimum direct gap: {min_gap_val:.3f} eV at k = {kpoints[min_gap_idx]:.3f} (Band {min_gap_label})")

    plt.xlabel("k-point distance (1/Å)")
    plt.ylabel("d(Ec - Ev)/dk (eV/Å)")
    plt.title(f"Gradient of Direct Gaps | Tolerance: {slope_tol} eV/Å")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    # Return DataFrame
    df = pd.DataFrame(records)
    return df

#Adjustable number of analyzed bands and slope tolerance
df = analyze_direct_bandgap_singularities(bs, N=4, slope_tol=5)
